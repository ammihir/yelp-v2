<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TasteLens Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
  <div class="app">

    <!-- ========== CHAT SCREEN ========== -->
    <div id="chat-screen" class="screen active">
    <header class="app-header app-header--grid">
      <div class="header-left">
        <div class="header-brand">
          <div class="app-title">TasteLens</div>
          <div class="yelp-center">
            <img src="{{ url_for('static', filename='img/yelp-logo.png') }}" alt="Yelp" />
            <span>Powered by Yelp</span>
          </div>
        </div>
      </div>

      <div class="header-center">
        <select id="language-selector" class="language-selector" title="Select language">
          <option value="en">English</option>
        </select>
      </div>

      <div class="header-right">
        <button id="group-btn" class="header-btn">Group</button>
        <button id="go-live-btn" class="header-btn">Live Scan</button>
      </div>
    </header>


      <main id="chat-container" class="chat-container">
        <!-- Messages go here -->
      </main>

      <form id="chat-form" class="chat-input-bar">
        <button type="button" id="attach-btn" class="attach-btn">+</button>

        <!-- Hidden file input for camera/gallery -->
        <input
          id="image-input"
          type="file"
          accept="image/*"
          capture="environment"
          hidden
        />

        <input
          id="chat-input"
          class="chat-input"
          type="text"
          placeholder="Send a message..."
          autocomplete="off"
          required
        />
        <button type="button" id="mic-btn" class="mic-btn" title="Voice input">üé§</button>
        <button class="chat-send-btn" type="submit">‚û§</button>
      </form>
    </div>


<!-- ========== LIVE VIDEO SCREEN ========== -->
    <div id="live-screen" class="screen">
    <header class="app-header app-header--grid">
      <div class="header-left">
        <button id="back-to-chat-btn" class="header-btn">‚Üê</button>
      </div>

      <div class="header-center">
        <div class="app-title">Live Scan</div>
        <div class="yelp-center">
          <img src="{{ url_for('static', filename='img/yelp-logo.png') }}" alt="Yelp" />
          <span>Powered by Yelp</span>
        </div>
      </div>

      <div class="header-right"></div>
    </header>


      <main class="live-container">
        <video id="live-video" class="live-video" autoplay playsinline muted></video>
        
        <div class="live-mask"></div>

        <!-- Curved frame overlay -->
        
        <div id="live-frame" class="live-frame">
          <svg class="neon-svg" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
            <defs>
              <!-- Soft neon glow -->
              <filter id="neonGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="2.2" result="blur"/>
                <feMerge>
                  <feMergeNode in="blur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>

              <!-- A base gradient so it looks like a strip, not flat -->
              <linearGradient id="neonGrad" x1="0" y1="0" x2="1" y2="0">
                <stop offset="0%" stop-color="#ff2d55"/>
                <stop offset="50%" stop-color="#00e5ff"/>
                <stop offset="100%" stop-color="#b026ff"/>
              </linearGradient>
            </defs>

            <!-- One continuous ‚Äútube‚Äù around the frame -->
            <rect class="neon-rect" x="3" y="3" width="94" height="94" rx="18" ry="18" fill="none"/>
          </svg>
        </div>



        <!-- Overlay UI on top of video -->
        <div class="live-overlay">
          <div class="live-instructions">
            Align a storefront inside the frame and tap ‚ÄúScan‚Äù.
          </div>

          <button id="live-scan-btn" class="scan-btn">
            Scan inside frame
          </button>

          <div id="live-result-card" class="live-result-card hidden">
          <div class="live-result-title">
            Rating & reviews <span class="ai-badge">AI summary</span>
          </div>
            <div id="live-result-text" class="live-result-text"></div>
            <div class="live-result-buttons">
              <button id="live-view-more-btn" class="live-view-more-btn">
                View more in chat
              </button>
              <button id="live-share-to-group-btn" class="live-share-btn">
                Share to Group
              </button>
            </div>
          </div>
        </div>
      </main>
    </div>

    <!-- Hidden audio player for TTS -->
    <audio id="tts-audio" preload="none"></audio>

    <!-- ========== GROUP MODAL ========== -->
    <div id="group-modal" class="modal hidden">
      <div class="modal-content">
        <button id="close-modal-btn" class="modal-close">&times;</button>

        <!-- Create/Join selection -->
        <div id="group-start-view" class="group-view">
          <h2>Group Chat</h2>
          <p class="modal-subtitle">Decide where to eat together!</p>

          <div class="group-options">
            <button id="create-group-option" class="group-option-btn">
              <span class="option-icon">+</span>
              <span class="option-text">Create Group</span>
            </button>
            <button id="join-group-option" class="group-option-btn">
              <span class="option-icon">&#x2192;</span>
              <span class="option-text">Join Group</span>
            </button>
          </div>
        </div>

        <!-- Create group form -->
        <div id="group-create-view" class="group-view hidden">
          <h2>Create Group</h2>
          <form id="create-group-form" class="group-form">
            <label for="group-name-input">Group Name</label>
            <input type="text" id="group-name-input" placeholder="Friday Lunch Crew" maxlength="50" required />

            <label for="create-nickname-input">Your Nickname</label>
            <input type="text" id="create-nickname-input" placeholder="Enter your name" maxlength="20" required />

            <button type="submit" class="group-submit-btn">Create Group</button>
            <button type="button" id="back-to-start-1" class="group-back-btn">Back</button>
          </form>
        </div>

        <!-- Join group form -->
        <div id="group-join-view" class="group-view hidden">
          <h2>Join Group</h2>
          <form id="join-group-form" class="group-form">
            <label for="join-group-id-input">Group Code</label>
            <input type="text" id="join-group-id-input" placeholder="Enter 8-char code" maxlength="8" required />

            <label for="join-nickname-input">Your Nickname</label>
            <input type="text" id="join-nickname-input" placeholder="Enter your name" maxlength="20" required />

            <button type="submit" class="group-submit-btn">Join Group</button>
            <button type="button" id="back-to-start-2" class="group-back-btn">Back</button>
          </form>
        </div>

        <!-- Share link view -->
        <div id="group-share-view" class="group-view hidden">
          <h2>Group Created!</h2>
          <p>Share this link with friends:</p>
          <div class="share-link-box">
            <input type="text" id="share-link-input" readonly />
            <button type="button" id="copy-link-btn" class="copy-btn">Copy</button>
          </div>
          <button type="button" id="enter-group-btn" class="group-submit-btn">Enter Group Chat</button>
        </div>
      </div>
    </div>

    <!-- ========== GROUP CHAT SCREEN ========== -->
    <div id="group-screen" class="screen">
      <header class="app-header app-header--grid">
        <div class="header-left">
          <button id="leave-group-btn" class="header-btn">Leave</button>
        </div>

        <div class="header-center">
          <div class="app-title" id="group-title">Group Chat</div>
          <div class="group-members-count" id="group-members-count"></div>
        </div>

        <div class="header-right">
          <button id="group-live-scan-btn" class="header-btn">Scan</button>
          <button id="group-share-btn" class="header-btn">Share</button>
        </div>
      </header>

      <div class="group-layout">
        <!-- Restaurant sidebar -->
        <aside id="group-restaurants" class="group-sidebar">
          <div class="sidebar-header">
            <h3>Shared Restaurants</h3>
          </div>
          <div id="restaurant-list" class="restaurant-list">
            <!-- Shared restaurants appear here -->
            <div class="empty-state">No restaurants shared yet</div>
          </div>
        </aside>

        <!-- Group chat area -->
        <main class="group-main">
          <div id="group-chat-container" class="chat-container group-chat">
            <!-- Group messages go here -->
          </div>

          <form id="group-chat-form" class="chat-input-bar">
            <input
              id="group-chat-input"
              class="chat-input"
              type="text"
              placeholder="Message the group..."
              autocomplete="off"
              required
            />
            <button class="chat-send-btn" type="submit">&#10148;</button>
          </form>
        </main>
      </div>
    </div>

  </div>

  <script>
    // ---------- DOM Elements ----------
    const chatScreen = document.getElementById("chat-screen");
    const liveScreen = document.getElementById("live-screen");
    const groupScreen = document.getElementById("group-screen");
    const goLiveBtn = document.getElementById("go-live-btn");
    const backToChatBtn = document.getElementById("back-to-chat-btn");

    const form = document.getElementById("chat-form");
    const input = document.getElementById("chat-input");
    const chatContainer = document.getElementById("chat-container");
    const attachBtn = document.getElementById("attach-btn");
    const imageInput = document.getElementById("image-input");

    const liveVideo = document.getElementById("live-video");
    let videoStream = null;

    // Language & TTS/STT elements
    const languageSelector = document.getElementById("language-selector");
    const ttsAudio = document.getElementById("tts-audio");
    const micBtn = document.getElementById("mic-btn");
    let ttsEnabled = false;
    let sttEnabled = false;
    let currentLanguage = localStorage.getItem("selectedLanguage") || "en";

    // STT recording state
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;



    
    // ---------- Message helpers ----------
    function appendMessage(text, role, extraClass) {
      const msg = document.createElement("div");
      msg.classList.add("message");
      if (role === "user") msg.classList.add("message-user");
      else msg.classList.add("message-bot");
      if (extraClass) msg.classList.add(extraClass);

      // Create text content span
      const textSpan = document.createElement("span");
      textSpan.classList.add("message-text");
      textSpan.textContent = text;
      msg.appendChild(textSpan);

      // Add TTS button for bot messages (if TTS is enabled)
      if (role === "bot" && ttsEnabled && !extraClass) {
        const ttsBtn = document.createElement("button");
        ttsBtn.classList.add("tts-btn");
        ttsBtn.innerHTML = "üîä";
        ttsBtn.title = "Listen";
        ttsBtn.onclick = () => playTTS(text, ttsBtn);
        msg.appendChild(ttsBtn);
      }

      chatContainer.appendChild(msg);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // ---------- Language & TTS/STT Functions ----------
    async function loadLanguages() {
      try {
        const res = await fetch("/get_languages");
        const data = await res.json();

        ttsEnabled = data.tts_enabled;
        sttEnabled = data.stt_enabled;

        // Show/hide mic button based on STT availability
        if (sttEnabled) {
          micBtn.style.display = "flex";
        } else {
          micBtn.style.display = "none";
        }

        // Populate language selector
        languageSelector.innerHTML = "";
        data.languages.forEach(lang => {
          const option = document.createElement("option");
          option.value = lang.code;
          option.textContent = lang.name;
          if (lang.code === currentLanguage) {
            option.selected = true;
          }
          languageSelector.appendChild(option);
        });

        // Sync with server
        if (currentLanguage !== data.current) {
          await setLanguage(currentLanguage);
        }
      } catch (err) {
        console.error("Failed to load languages:", err);
      }
    }

    async function setLanguage(langCode) {
      try {
        const res = await fetch("/set_language", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ language: langCode }),
        });
        const data = await res.json();
        if (data.status === "ok") {
          currentLanguage = langCode;
          localStorage.setItem("selectedLanguage", langCode);
        }
      } catch (err) {
        console.error("Failed to set language:", err);
      }
    }

    languageSelector.addEventListener("change", async (e) => {
      const newLang = e.target.value;
      await setLanguage(newLang);
      // Show confirmation message
      appendMessage(`Language changed to ${e.target.options[e.target.selectedIndex].text}`, "bot");
    });

    async function playTTS(text, btn) {
      if (!ttsEnabled) return;

      const originalText = btn.innerHTML;
      btn.innerHTML = "...";
      btn.disabled = true;

      try {
        const res = await fetch("/tts", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text, language: currentLanguage }),
        });
        const data = await res.json();

        if (data.audio_url) {
          ttsAudio.src = data.audio_url;
          ttsAudio.play();
          btn.innerHTML = "üîà";

          ttsAudio.onended = () => {
            btn.innerHTML = originalText;
          };
        } else {
          btn.innerHTML = originalText;
          console.error("TTS error:", data.error);
        }
      } catch (err) {
        console.error("TTS playback error:", err);
        btn.innerHTML = originalText;
      } finally {
        btn.disabled = false;
      }
    }

    // Initialize languages on load
    loadLanguages();

    // ---------- STT (Voice Recording) ----------
    async function startRecording() {
      if (!sttEnabled) return;

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
        audioChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            audioChunks.push(e.data);
          }
        };

        mediaRecorder.onstop = async () => {
          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());

          if (audioChunks.length === 0) {
            micBtn.classList.remove("recording");
            micBtn.innerHTML = "üé§";
            isRecording = false;
            return;
          }

          const audioBlob = new Blob(audioChunks, { type: "audio/webm" });

          // Show processing state
          micBtn.innerHTML = "...";
          micBtn.disabled = true;

          try {
            const formData = new FormData();
            formData.append("audio", audioBlob, "recording.webm");

            const res = await fetch("/stt", {
              method: "POST",
              body: formData,
            });
            const data = await res.json();

            if (data.status === "ok" && data.text) {
              // Put transcribed text in input field
              input.value = data.text;
              input.focus();

              // Handle auto language detection
              if (data.language_changed && data.detected_language) {
                currentLanguage = data.detected_language;
                localStorage.setItem("selectedLanguage", data.detected_language);
                // Update the dropdown
                languageSelector.value = data.detected_language;
                // Notify user
                appendMessage(`Language detected: ${data.language_name}`, "bot");
              }
            } else if (data.error) {
              console.error("STT error:", data.error);
              appendMessage("Could not understand audio. Please try again.", "bot");
            }
          } catch (err) {
            console.error("STT request error:", err);
            appendMessage("Voice input error. Please try again.", "bot");
          } finally {
            micBtn.classList.remove("recording");
            micBtn.innerHTML = "üé§";
            micBtn.disabled = false;
            isRecording = false;
          }
        };

        mediaRecorder.start();
        isRecording = true;
        micBtn.classList.add("recording");
        micBtn.innerHTML = "‚èπ";
      } catch (err) {
        console.error("Microphone access error:", err);
        appendMessage("Could not access microphone. Please check permissions.", "bot");
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
      }
    }

    micBtn.addEventListener("click", () => {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    });

    // ---------- Location ----------
    function refreshLocation() {
      return new Promise((resolve) => {
        if (!("geolocation" in navigator)) {
          resolve();
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            fetch("/update_location", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                lat: pos.coords.latitude,
                lon: pos.coords.longitude,
              }),
            })
              .catch(console.error)
              .finally(resolve);
          },
          (err) => {
            console.warn("Geolocation error:", err);
            resolve();
          },
          { enableHighAccuracy: true }
        );
      });
    }

    // Initial location push (optional)
    refreshLocation().catch(console.error);

    // ---------- Chat submit ----------
form.addEventListener("submit", async (e) => {
  e.preventDefault();
  const text = input.value.trim();
  if (!text) return;

  appendMessage(text, "user");
  input.value = "";
  input.focus();

  await refreshLocation();

  const typingBubble = document.createElement("div");
  typingBubble.classList.add("message", "message-bot", "typing");
  typingBubble.textContent = "Thinking‚Ä¶";
  chatContainer.appendChild(typingBubble);
  chatContainer.scrollTop = chatContainer.scrollHeight;

  try {
    // ‚úÖ Only inject context if you actually have a live scan result
    if (lastLiveResultJson) {
      await fetch("/inject_context", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ card: lastLiveResultJson }),
      });
    }

    // ‚úÖ THIS is the real chat call
    const res = await fetch("/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ message: text }),
    });

    const data = await res.json();
    chatContainer.removeChild(typingBubble);

    // Debug: log the full response
    console.log("Chat response:", data);
    console.log("Language:", data.language);
    console.log("Reply:", data.reply);

    appendMessage(data.reply || data.error || "No reply", "bot");
  } catch (err) {
    chatContainer.removeChild(typingBubble);
    appendMessage("Error talking to server.", "bot");
    console.error(err);
  }
});


    // ---------- Image upload ----------
    attachBtn.addEventListener("click", () => {
      imageInput.click();
    });

    imageInput.addEventListener("change", async () => {
      if (!imageInput.files || !imageInput.files[0]) return;
      const file = imageInput.files[0];

      // Show a thumbnail bubble like ChatGPT
      const reader = new FileReader();
      reader.onload = () => {
        const wrapper = document.createElement("div");
        wrapper.classList.add("message", "message-user", "image-message");

        const img = document.createElement("img");
        img.src = reader.result;
        wrapper.appendChild(img);

        chatContainer.appendChild(wrapper);
        chatContainer.scrollTop = chatContainer.scrollHeight;
      };
      reader.readAsDataURL(file);

      // Update location before sending
      await refreshLocation();

      const typingBubble = document.createElement("div");
      typingBubble.classList.add("message", "message-bot", "typing");
      typingBubble.textContent = "Analyzing image‚Ä¶";
      chatContainer.appendChild(typingBubble);
      chatContainer.scrollTop = chatContainer.scrollHeight;

      const formData = new FormData();
      formData.append("image", file);

      try {
        const res = await fetch("/upload_image", {
          method: "POST",
          body: formData,
        });
        const data = await res.json();
        chatContainer.removeChild(typingBubble);
        appendMessage(data.reply || "Image received.", "bot");
      } catch (err) {
        chatContainer.removeChild(typingBubble);
        appendMessage("Error uploading image.", "bot");
        console.error(err);
      } finally {
        imageInput.value = "";
      }
    });

    // ---------- Live video (AR-like) ----------
    async function startVideoStream() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("Camera not supported on this device/browser.");
        return;
      }
      try {
        videoStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio: false,
        });
        liveVideo.srcObject = videoStream;
      } catch (err) {
        console.error("Error starting video:", err);
        alert("Could not start camera.");
      }
    }

    function stopVideoStream() {
      if (videoStream) {
        videoStream.getTracks().forEach((t) => t.stop());
        videoStream = null;
      }
      liveVideo.srcObject = null;
    }

    // Track which screen user came from before going to live scan
    let previousScreen = "chat"; // "chat" or "group"

    function showChatScreen() {
      chatScreen.classList.add("active");
      liveScreen.classList.remove("active");
      groupScreen.classList.remove("active");
    }

    function showLiveScreen() {
      liveScreen.classList.add("active");
      chatScreen.classList.remove("active");
      groupScreen.classList.remove("active");
    }

    function showGroupScreen() {
      groupScreen.classList.add("active");
      chatScreen.classList.remove("active");
      liveScreen.classList.remove("active");
    }

    goLiveBtn.addEventListener("click", async () => {
      previousScreen = "chat";
      showLiveScreen();
      await startVideoStream();
      // Optional: refresh location on entering live view
      refreshLocation().catch(console.error);
    });

    // Group live scan button
    const groupLiveScanBtn = document.getElementById("group-live-scan-btn");
    groupLiveScanBtn.addEventListener("click", async () => {
      previousScreen = "group";
      showLiveScreen();
      await startVideoStream();
      refreshLocation().catch(console.error);
    });

    backToChatBtn.addEventListener("click", () => {
      stopVideoStream();
      if (previousScreen === "group" && currentGroupId) {
        showGroupScreen();
      } else {
        showChatScreen();
      }
    });

    window.addEventListener("load", () => {
      input.focus();
    });

const liveScanBtn = document.getElementById("live-scan-btn");
const liveResultCard = document.getElementById("live-result-card");
const liveResultText = document.getElementById("live-result-text");
const liveViewMoreBtn = document.getElementById("live-view-more-btn");
const liveShareToGroupBtn = document.getElementById("live-share-to-group-btn");
const liveFrame = document.getElementById("live-frame");

let lastLiveResultJson = null;

// Tap the frame to scan
liveFrame.addEventListener("click", () => liveScanBtn.click());

async function captureFrameFromVideo() {
  if (!liveVideo || !liveVideo.videoWidth || !liveVideo.videoHeight) {
    throw new Error("Video not ready");
  }

  const vw = liveVideo.videoWidth;
  const vh = liveVideo.videoHeight;

  const frameWidthRatio = 0.7;
  const frameHeightRatio = 0.4;
  const frameTopRatio = 0.2;

  const sw = vw * frameWidthRatio;
  const sh = vh * frameHeightRatio;
  const sx = (vw - sw) / 2;
  const sy = vh * frameTopRatio;

  const canvas = document.createElement("canvas");
  canvas.width = Math.floor(sw);
  canvas.height = Math.floor(sh);

  const ctx = canvas.getContext("2d");
  ctx.drawImage(liveVideo, sx, sy, sw, sh, 0, 0, sw, sh);

  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob) => (blob ? resolve(blob) : reject(new Error("Failed to create blob"))),
      "image/jpeg",
      0.9
    );
  });
}

liveScanBtn.addEventListener("click", async () => {
  await refreshLocation();

  liveScanBtn.disabled = true;
  liveScanBtn.textContent = "Scanning‚Ä¶";
  liveFrame.classList.add("scanning");


  try {
    const blob = await captureFrameFromVideo();
    const formData = new FormData();
    formData.append("image", blob, "live_frame.jpg");

    const res = await fetch("/live_scan", { method: "POST", body: formData });
    const data = await res.json();

    if (data.error) {
      lastLiveResultJson = null;
      liveResultText.textContent = data.error;
      liveResultCard.classList.remove("hidden");
      return;
    }

    lastLiveResultJson = data;

    const enriched = data.enriched;
    const top = data.top_pick;
    const aiText = data.yelp_ai?.text;

    if (enriched) {
      const ratingLine =
        `‚≠ê ${enriched.rating ?? "‚Äî"} (${enriched.review_count ?? "‚Äî"})` +
        (enriched.price ? ` ‚Ä¢ ${enriched.price}` : "");
      const oneLiner = enriched.ai_summary?.one_liner ? `\n${enriched.ai_summary.one_liner}` : "";
      liveResultText.textContent = `${enriched.name}\n${ratingLine}${oneLiner}`;
    } else if (top) {
      const ratingLine =
        `‚≠ê ${top.rating ?? "‚Äî"} (${top.review_count ?? "‚Äî"})` +
        (top.price ? ` ‚Ä¢ ${top.price}` : "");
      liveResultText.textContent = `${top.name}\n${ratingLine}` + (aiText ? `\n\nü§ñ ${aiText}` : "");
    } else {
      liveResultText.textContent = aiText || "No matching businesses found.";
    }

    liveResultCard.classList.remove("hidden");
  } catch (err) {
    console.error("Live scan error:", err);
    lastLiveResultJson = null;
    liveResultText.textContent = "Error analyzing this view.";
    liveResultCard.classList.remove("hidden");
  } finally {
    liveScanBtn.disabled = false;
    liveScanBtn.textContent = "Scan inside frame";
    liveFrame.classList.remove("scanning");

  }
});

// Share to group button handler
liveShareToGroupBtn.addEventListener("click", async () => {
  if (!currentGroupId) {
    alert("Join or create a group first to share restaurants!");
    return;
  }

  if (!lastLiveResultJson) {
    alert("Scan a restaurant first!");
    return;
  }

  const enriched = lastLiveResultJson.enriched;
  const top = lastLiveResultJson.top_pick;
  const restaurant = enriched || top;

  if (!restaurant) {
    alert("No restaurant data to share. Try scanning again.");
    return;
  }

  try {
    const res = await fetch(`/group/${currentGroupId}/share_restaurant`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ restaurant }),
    });
    const data = await res.json();

    if (data.status === "ok") {
      updateRestaurantList(data.restaurants);
      pollGroupMessages();
      liveShareToGroupBtn.textContent = "Shared!";
      liveShareToGroupBtn.disabled = true;
      setTimeout(() => {
        liveShareToGroupBtn.textContent = "Share to Group";
        liveShareToGroupBtn.disabled = false;
      }, 2000);
    } else if (data.error === "Group not found") {
      // Group was lost (server restart clears in-memory groups)
      alert("Group session expired. Please rejoin or create a new group.");
      currentGroupId = null;
      currentUserId = null;
      currentNickname = null;
    } else {
      alert(data.error || "Failed to share restaurant");
    }
  } catch (err) {
    console.error("Share to group error:", err);
    alert("Failed to share restaurant");
  }
});

liveViewMoreBtn.addEventListener("click", async () => {
  if (lastLiveResultJson) {
    const enriched = lastLiveResultJson.enriched;
    const top = lastLiveResultJson.top_pick;
    const aiText = lastLiveResultJson.yelp_ai?.text;

    const lines = [];
    lines.push("üìç Live Scan Result");

    if (enriched) {
      lines.push(enriched.name);
      lines.push(`‚≠ê ${enriched.rating ?? "‚Äî"} (${enriched.review_count ?? "‚Äî"})${enriched.price ? " ‚Ä¢ " + enriched.price : ""}`);
      if (enriched.ai_summary?.one_liner) lines.push(`üß† ${enriched.ai_summary.one_liner}`);
    } else if (top) {
      lines.push(top.name);
      lines.push(`‚≠ê ${top.rating ?? "‚Äî"} (${top.review_count ?? "‚Äî"})${top.price ? " ‚Ä¢ " + top.price : ""}`);
    } else {
      lines.push("No top match found.");
    }

    if (aiText) {
      lines.push("");
      lines.push(aiText);
    }

    // 1) Add to UI chat
    appendMessage(lines.join("\n"), "bot");

    // 2) Inject into Yelp context (so followups know what was scanned)
    try {
      await fetch("/inject_context", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ card: lastLiveResultJson }),
      });
    } catch (e) {
      console.error("Failed to inject context:", e);
    }}


  stopVideoStream();
  showChatScreen();
});

// ========== GROUP CHAT ==========
const groupBtn = document.getElementById("group-btn");
const groupModal = document.getElementById("group-modal");
const closeModalBtn = document.getElementById("close-modal-btn");

// Modal views
const groupStartView = document.getElementById("group-start-view");
const groupCreateView = document.getElementById("group-create-view");
const groupJoinView = document.getElementById("group-join-view");
const groupShareView = document.getElementById("group-share-view");

// Forms and inputs
const createGroupForm = document.getElementById("create-group-form");
const joinGroupForm = document.getElementById("join-group-form");
const groupNameInput = document.getElementById("group-name-input");
const createNicknameInput = document.getElementById("create-nickname-input");
const joinGroupIdInput = document.getElementById("join-group-id-input");
const joinNicknameInput = document.getElementById("join-nickname-input");
const shareLinkInput = document.getElementById("share-link-input");
const copyLinkBtn = document.getElementById("copy-link-btn");
const enterGroupBtn = document.getElementById("enter-group-btn");

// Group screen elements
const groupTitle = document.getElementById("group-title");
const groupMembersCount = document.getElementById("group-members-count");
const groupChatContainer = document.getElementById("group-chat-container");
const groupChatForm = document.getElementById("group-chat-form");
const groupChatInput = document.getElementById("group-chat-input");
const restaurantList = document.getElementById("restaurant-list");
const leaveGroupBtn = document.getElementById("leave-group-btn");
const groupShareBtn = document.getElementById("group-share-btn");

// Group state
let currentGroupId = null;
let currentUserId = null;
let currentNickname = null;
let lastMessageTimestamp = 0;
let pollInterval = null;

// Show/hide modal views
function showModalView(view) {
  [groupStartView, groupCreateView, groupJoinView, groupShareView].forEach(v => v.classList.add("hidden"));
  view.classList.remove("hidden");
}

function openModal() {
  groupModal.classList.remove("hidden");
  showModalView(groupStartView);
}

function closeModal() {
  groupModal.classList.add("hidden");
}

// Modal navigation
groupBtn.addEventListener("click", openModal);
closeModalBtn.addEventListener("click", closeModal);
groupModal.addEventListener("click", (e) => {
  if (e.target === groupModal) closeModal();
});

document.getElementById("create-group-option").addEventListener("click", () => showModalView(groupCreateView));
document.getElementById("join-group-option").addEventListener("click", () => showModalView(groupJoinView));
document.getElementById("back-to-start-1").addEventListener("click", () => showModalView(groupStartView));
document.getElementById("back-to-start-2").addEventListener("click", () => showModalView(groupStartView));

// Create group
createGroupForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  const name = groupNameInput.value.trim();
  const nickname = createNicknameInput.value.trim();

  if (!name || !nickname) return;

  try {
    const res = await fetch("/group/create", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name, nickname }),
    });
    const data = await res.json();

    if (data.status === "ok") {
      currentGroupId = data.group_id;
      currentUserId = data.user_id;
      currentNickname = nickname;

      // Show share link
      const shareUrl = window.location.origin + `/group/${data.group_id}`;
      shareLinkInput.value = shareUrl;
      showModalView(groupShareView);
    } else {
      alert(data.error || "Failed to create group");
    }
  } catch (err) {
    console.error("Create group error:", err);
    alert("Failed to create group");
  }
});

// Copy share link
copyLinkBtn.addEventListener("click", () => {
  shareLinkInput.select();
  document.execCommand("copy");
  copyLinkBtn.textContent = "Copied!";
  setTimeout(() => copyLinkBtn.textContent = "Copy", 2000);
});

// Enter group after creation
enterGroupBtn.addEventListener("click", () => {
  closeModal();
  enterGroupChat();
});

// Join group
joinGroupForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  const groupId = joinGroupIdInput.value.trim().toLowerCase();
  const nickname = joinNicknameInput.value.trim();

  if (!groupId || !nickname) return;

  try {
    const res = await fetch(`/group/${groupId}/join`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ nickname }),
    });
    const data = await res.json();

    if (data.status === "ok") {
      currentGroupId = data.group_id;
      currentUserId = data.user_id;
      currentNickname = nickname;
      closeModal();
      enterGroupChat();
    } else {
      alert(data.error || "Failed to join group");
    }
  } catch (err) {
    console.error("Join group error:", err);
    alert("Failed to join group");
  }
});

// Enter group chat screen
async function enterGroupChat() {
  if (!currentGroupId) return;

  // Switch to group screen
  showGroupScreen();

  // Load group info
  try {
    const res = await fetch(`/group/${currentGroupId}/info`);
    const data = await res.json();

    groupTitle.textContent = data.name;
    groupMembersCount.textContent = `${data.member_count} member${data.member_count !== 1 ? "s" : ""}`;

    // Load restaurants
    updateRestaurantList(data.restaurants);
  } catch (err) {
    console.error("Load group info error:", err);
  }

  // Start polling for messages
  lastMessageTimestamp = 0;
  groupChatContainer.innerHTML = "";
  pollGroupMessages();
  pollInterval = setInterval(pollGroupMessages, 2000);
}

// Poll for new messages
async function pollGroupMessages() {
  if (!currentGroupId) return;

  try {
    const res = await fetch(`/group/${currentGroupId}/messages?since=${lastMessageTimestamp}`);
    const data = await res.json();

    if (data.messages && data.messages.length > 0) {
      data.messages.forEach(msg => {
        appendGroupMessage(msg);
        lastMessageTimestamp = Math.max(lastMessageTimestamp, msg.timestamp);
      });
    }

    // Update member count
    if (data.members) {
      groupMembersCount.textContent = `${data.members.length} member${data.members.length !== 1 ? "s" : ""}`;
    }
  } catch (err) {
    console.error("Poll messages error:", err);
  }
}

// Append message to group chat
function appendGroupMessage(msg) {
  const div = document.createElement("div");
  div.classList.add("message", "group-message");
  div.dataset.id = msg.id;

  if (msg.type === "system") {
    div.classList.add("system-message");
    div.textContent = msg.text;
  } else if (msg.type === "chat") {
    const isMe = msg.user_id === currentUserId;
    div.classList.add(isMe ? "message-user" : "message-other");

    if (!isMe) {
      const nameSpan = document.createElement("span");
      nameSpan.classList.add("message-author");
      nameSpan.textContent = msg.nickname;
      div.appendChild(nameSpan);
    }

    const textSpan = document.createElement("span");
    textSpan.classList.add("message-text");
    textSpan.textContent = msg.text;
    div.appendChild(textSpan);
  } else if (msg.type === "restaurant_share") {
    div.classList.add("restaurant-message");
    const r = msg.restaurant;

    div.innerHTML = `
      <span class="message-author">${msg.nickname}</span> shared a restaurant:
      <div class="shared-restaurant">
        <strong>${r.name}</strong>
        ${r.rating ? `<span class="rating">‚≠ê ${r.rating}</span>` : ""}
        ${r.price ? `<span class="price">${r.price}</span>` : ""}
        ${r.url ? `<a href="${r.url}" target="_blank" class="yelp-link">View on Yelp</a>` : ""}
      </div>
    `;
  }

  groupChatContainer.appendChild(div);
  groupChatContainer.scrollTop = groupChatContainer.scrollHeight;
}

// Send group message
groupChatForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  const text = groupChatInput.value.trim();
  if (!text || !currentGroupId) return;

  groupChatInput.value = "";

  try {
    await fetch(`/group/${currentGroupId}/send`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text }),
    });
    // Message will appear on next poll
  } catch (err) {
    console.error("Send message error:", err);
  }
});

// Update restaurant list in sidebar with voting
function updateRestaurantList(restaurants) {
  if (!restaurants || restaurants.length === 0) {
    restaurantList.innerHTML = '<div class="empty-state">No restaurants shared yet</div>';
    return;
  }

  // Find the winner (most votes, at least 1 vote)
  let maxVotes = 0;
  let winnerId = null;
  restaurants.forEach(r => {
    const voteCount = (r.votes || []).length;
    if (voteCount > maxVotes) {
      maxVotes = voteCount;
      winnerId = r.business_id;
    }
  });

  restaurantList.innerHTML = restaurants.map(r => {
    const votes = r.votes || [];
    const voteCount = votes.length;
    const hasVoted = votes.some(v => v.user_id === currentUserId);
    const isWinner = winnerId === r.business_id && maxVotes > 0;
    const voterNames = votes.map(v => v.nickname).join(", ");

    return `
    <div class="restaurant-card ${isWinner ? 'winner' : ''}" data-id="${r.business_id}">
      ${isWinner ? '<div class="winner-badge">Top Pick!</div>' : ''}
      <div class="restaurant-name">${r.name}</div>
      <div class="restaurant-meta">
        ${r.rating ? `‚≠ê ${r.rating}` : ""}
        ${r.price ? `‚Ä¢ ${r.price}` : ""}
      </div>
      <div class="restaurant-shared-by">Shared by ${r.shared_by}</div>
      <div class="vote-section">
        <button class="vote-btn ${hasVoted ? 'voted' : ''}" data-business-id="${r.business_id}" onclick="toggleVote('${r.business_id}', ${hasVoted})">
          ${hasVoted ? '‚ô•' : '‚ô°'} ${voteCount}
        </button>
        ${voterNames ? `<span class="voter-names" title="${voterNames}">${voterNames}</span>` : ''}
      </div>
      ${r.url ? `<a href="${r.url}" target="_blank" class="yelp-link">View on Yelp</a>` : ""}
    </div>
  `}).join("");
}

// Toggle vote for a restaurant
async function toggleVote(businessId, hasVoted) {
  if (!currentGroupId) return;

  const endpoint = hasVoted ? 'unvote' : 'vote';

  try {
    const res = await fetch(`/group/${currentGroupId}/${endpoint}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ business_id: businessId }),
    });
    const data = await res.json();

    if (data.status === "ok") {
      updateRestaurantList(data.restaurants);
      // Poll immediately to show the vote message
      pollGroupMessages();
    } else {
      console.error("Vote error:", data.error);
    }
  } catch (err) {
    console.error("Vote request error:", err);
  }
}

// Leave group
leaveGroupBtn.addEventListener("click", async () => {
  if (!currentGroupId) return;

  if (!confirm("Leave this group?")) return;

  try {
    await fetch(`/group/${currentGroupId}/leave`, { method: "POST" });
  } catch (err) {
    console.error("Leave group error:", err);
  }

  // Clear state and return to chat
  clearInterval(pollInterval);
  currentGroupId = null;
  currentUserId = null;
  currentNickname = null;
  lastMessageTimestamp = 0;

  showChatScreen();
});

// Share group link
groupShareBtn.addEventListener("click", () => {
  const shareUrl = window.location.origin + `/group/${currentGroupId}`;
  if (navigator.share) {
    navigator.share({ title: "Join my group!", url: shareUrl });
  } else {
    navigator.clipboard.writeText(shareUrl);
    alert("Link copied to clipboard!");
  }
});

// Check for group ID in URL on page load (for shareable links)
(function checkGroupInUrl() {
  const path = window.location.pathname;
  const match = path.match(/^\/group\/([a-z0-9]+)$/i);

  if (match) {
    const groupId = match[1];
    // Pre-fill the join form
    joinGroupIdInput.value = groupId;
    openModal();
    showModalView(groupJoinView);
  }
})();



  </script>
</body>
</html>
