<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TasteLens Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
  <div class="app">

    <!-- ========== CHAT SCREEN ========== -->
    <div id="chat-screen" class="screen active">
    <header class="app-header app-header--grid">
      <div class="header-left">
        <div class="header-brand">
          <div class="app-title">TasteLens</div>
          <div class="yelp-center">
            <img src="{{ url_for('static', filename='img/yelp-logo.png') }}" alt="Yelp" />
            <span>Powered by Yelp</span>
          </div>
        </div>
      </div>

      <div class="header-center">
        <select id="language-selector" class="language-selector" title="Select language">
          <option value="en">English</option>
        </select>
      </div>

      <div class="header-right">
        <button id="go-live-btn" class="header-btn">Live Scan</button>
      </div>
    </header>


      <main id="chat-container" class="chat-container">
        <!-- Messages go here -->
      </main>

      <form id="chat-form" class="chat-input-bar">
        <button type="button" id="attach-btn" class="attach-btn">+</button>

        <!-- Hidden file input for camera/gallery -->
        <input
          id="image-input"
          type="file"
          accept="image/*"
          capture="environment"
          hidden
        />

        <input
          id="chat-input"
          class="chat-input"
          type="text"
          placeholder="Send a message..."
          autocomplete="off"
          required
        />
        <button type="button" id="mic-btn" class="mic-btn" title="Voice input">üé§</button>
        <button class="chat-send-btn" type="submit">‚û§</button>
      </form>
    </div>


<!-- ========== LIVE VIDEO SCREEN ========== -->
    <div id="live-screen" class="screen">
    <header class="app-header app-header--grid">
      <div class="header-left">
        <button id="back-to-chat-btn" class="header-btn">‚Üê</button>
      </div>

      <div class="header-center">
        <div class="app-title">Live Scan</div>
        <div class="yelp-center">
          <img src="{{ url_for('static', filename='img/yelp-logo.png') }}" alt="Yelp" />
          <span>Powered by Yelp</span>
        </div>
      </div>

      <div class="header-right"></div>
    </header>


      <main class="live-container">
        <video id="live-video" class="live-video" autoplay playsinline muted></video>
        
        <div class="live-mask"></div>

        <!-- Curved frame overlay -->
        
        <div id="live-frame" class="live-frame">
          <svg class="neon-svg" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
            <defs>
              <!-- Soft neon glow -->
              <filter id="neonGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="2.2" result="blur"/>
                <feMerge>
                  <feMergeNode in="blur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>

              <!-- A base gradient so it looks like a strip, not flat -->
              <linearGradient id="neonGrad" x1="0" y1="0" x2="1" y2="0">
                <stop offset="0%" stop-color="#ff2d55"/>
                <stop offset="50%" stop-color="#00e5ff"/>
                <stop offset="100%" stop-color="#b026ff"/>
              </linearGradient>
            </defs>

            <!-- One continuous ‚Äútube‚Äù around the frame -->
            <rect class="neon-rect" x="3" y="3" width="94" height="94" rx="18" ry="18" fill="none"/>
          </svg>
        </div>



        <!-- Overlay UI on top of video -->
        <div class="live-overlay">
          <div class="live-instructions">
            Align a storefront inside the frame and tap ‚ÄúScan‚Äù.
          </div>

          <button id="live-scan-btn" class="scan-btn">
            Scan inside frame
          </button>

          <div id="live-result-card" class="live-result-card hidden">
          <div class="live-result-title">
            Rating & reviews <span class="ai-badge">AI summary</span>
          </div>
            <div id="live-result-text" class="live-result-text"></div>
            <button id="live-view-more-btn" class="live-view-more-btn">
              View more in chat
            </button>
          </div>
        </div>
      </main>
    </div>

    <!-- Hidden audio player for TTS -->
    <audio id="tts-audio" preload="none"></audio>

  </div>

  <script>
    // ---------- DOM Elements ----------
    const chatScreen = document.getElementById("chat-screen");
    const liveScreen = document.getElementById("live-screen");
    const goLiveBtn = document.getElementById("go-live-btn");
    const backToChatBtn = document.getElementById("back-to-chat-btn");

    const form = document.getElementById("chat-form");
    const input = document.getElementById("chat-input");
    const chatContainer = document.getElementById("chat-container");
    const attachBtn = document.getElementById("attach-btn");
    const imageInput = document.getElementById("image-input");

    const liveVideo = document.getElementById("live-video");
    let videoStream = null;

    // Language & TTS/STT elements
    const languageSelector = document.getElementById("language-selector");
    const ttsAudio = document.getElementById("tts-audio");
    const micBtn = document.getElementById("mic-btn");
    let ttsEnabled = false;
    let sttEnabled = false;
    let currentLanguage = localStorage.getItem("selectedLanguage") || "en";

    // STT recording state
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;



    
    // ---------- Message helpers ----------
    function appendMessage(text, role, extraClass) {
      const msg = document.createElement("div");
      msg.classList.add("message");
      if (role === "user") msg.classList.add("message-user");
      else msg.classList.add("message-bot");
      if (extraClass) msg.classList.add(extraClass);

      // Create text content span
      const textSpan = document.createElement("span");
      textSpan.classList.add("message-text");
      textSpan.textContent = text;
      msg.appendChild(textSpan);

      // Add TTS button for bot messages (if TTS is enabled)
      if (role === "bot" && ttsEnabled && !extraClass) {
        const ttsBtn = document.createElement("button");
        ttsBtn.classList.add("tts-btn");
        ttsBtn.innerHTML = "üîä";
        ttsBtn.title = "Listen";
        ttsBtn.onclick = () => playTTS(text, ttsBtn);
        msg.appendChild(ttsBtn);
      }

      chatContainer.appendChild(msg);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // ---------- Language & TTS/STT Functions ----------
    async function loadLanguages() {
      try {
        const res = await fetch("/get_languages");
        const data = await res.json();

        ttsEnabled = data.tts_enabled;
        sttEnabled = data.stt_enabled;

        // Show/hide mic button based on STT availability
        if (sttEnabled) {
          micBtn.style.display = "flex";
        } else {
          micBtn.style.display = "none";
        }

        // Populate language selector
        languageSelector.innerHTML = "";
        data.languages.forEach(lang => {
          const option = document.createElement("option");
          option.value = lang.code;
          option.textContent = lang.name;
          if (lang.code === currentLanguage) {
            option.selected = true;
          }
          languageSelector.appendChild(option);
        });

        // Sync with server
        if (currentLanguage !== data.current) {
          await setLanguage(currentLanguage);
        }
      } catch (err) {
        console.error("Failed to load languages:", err);
      }
    }

    async function setLanguage(langCode) {
      try {
        const res = await fetch("/set_language", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ language: langCode }),
        });
        const data = await res.json();
        if (data.status === "ok") {
          currentLanguage = langCode;
          localStorage.setItem("selectedLanguage", langCode);
        }
      } catch (err) {
        console.error("Failed to set language:", err);
      }
    }

    languageSelector.addEventListener("change", async (e) => {
      const newLang = e.target.value;
      await setLanguage(newLang);
      // Show confirmation message
      appendMessage(`Language changed to ${e.target.options[e.target.selectedIndex].text}`, "bot");
    });

    async function playTTS(text, btn) {
      if (!ttsEnabled) return;

      const originalText = btn.innerHTML;
      btn.innerHTML = "...";
      btn.disabled = true;

      try {
        const res = await fetch("/tts", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text, language: currentLanguage }),
        });
        const data = await res.json();

        if (data.audio_url) {
          ttsAudio.src = data.audio_url;
          ttsAudio.play();
          btn.innerHTML = "üîà";

          ttsAudio.onended = () => {
            btn.innerHTML = originalText;
          };
        } else {
          btn.innerHTML = originalText;
          console.error("TTS error:", data.error);
        }
      } catch (err) {
        console.error("TTS playback error:", err);
        btn.innerHTML = originalText;
      } finally {
        btn.disabled = false;
      }
    }

    // Initialize languages on load
    loadLanguages();

    // ---------- STT (Voice Recording) ----------
    async function startRecording() {
      if (!sttEnabled) return;

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
        audioChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            audioChunks.push(e.data);
          }
        };

        mediaRecorder.onstop = async () => {
          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());

          if (audioChunks.length === 0) {
            micBtn.classList.remove("recording");
            micBtn.innerHTML = "üé§";
            isRecording = false;
            return;
          }

          const audioBlob = new Blob(audioChunks, { type: "audio/webm" });

          // Show processing state
          micBtn.innerHTML = "...";
          micBtn.disabled = true;

          try {
            const formData = new FormData();
            formData.append("audio", audioBlob, "recording.webm");

            const res = await fetch("/stt", {
              method: "POST",
              body: formData,
            });
            const data = await res.json();

            if (data.status === "ok" && data.text) {
              // Put transcribed text in input field
              input.value = data.text;
              input.focus();
            } else if (data.error) {
              console.error("STT error:", data.error);
              appendMessage("Could not understand audio. Please try again.", "bot");
            }
          } catch (err) {
            console.error("STT request error:", err);
            appendMessage("Voice input error. Please try again.", "bot");
          } finally {
            micBtn.classList.remove("recording");
            micBtn.innerHTML = "üé§";
            micBtn.disabled = false;
            isRecording = false;
          }
        };

        mediaRecorder.start();
        isRecording = true;
        micBtn.classList.add("recording");
        micBtn.innerHTML = "‚èπ";
      } catch (err) {
        console.error("Microphone access error:", err);
        appendMessage("Could not access microphone. Please check permissions.", "bot");
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
      }
    }

    micBtn.addEventListener("click", () => {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    });

    // ---------- Location ----------
    function refreshLocation() {
      return new Promise((resolve) => {
        if (!("geolocation" in navigator)) {
          resolve();
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            fetch("/update_location", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                lat: pos.coords.latitude,
                lon: pos.coords.longitude,
              }),
            })
              .catch(console.error)
              .finally(resolve);
          },
          (err) => {
            console.warn("Geolocation error:", err);
            resolve();
          },
          { enableHighAccuracy: true }
        );
      });
    }

    // Initial location push (optional)
    refreshLocation().catch(console.error);

    // ---------- Chat submit ----------
form.addEventListener("submit", async (e) => {
  e.preventDefault();
  const text = input.value.trim();
  if (!text) return;

  appendMessage(text, "user");
  input.value = "";
  input.focus();

  await refreshLocation();

  const typingBubble = document.createElement("div");
  typingBubble.classList.add("message", "message-bot", "typing");
  typingBubble.textContent = "Thinking‚Ä¶";
  chatContainer.appendChild(typingBubble);
  chatContainer.scrollTop = chatContainer.scrollHeight;

  try {
    // ‚úÖ Only inject context if you actually have a live scan result
    if (lastLiveResultJson) {
      await fetch("/inject_context", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ card: lastLiveResultJson }),
      });
    }

    // ‚úÖ THIS is the real chat call
    const res = await fetch("/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ message: text }),
    });

    const data = await res.json();
    chatContainer.removeChild(typingBubble);

    appendMessage(data.reply || data.error || "No reply", "bot");
  } catch (err) {
    chatContainer.removeChild(typingBubble);
    appendMessage("Error talking to server.", "bot");
    console.error(err);
  }
});


    // ---------- Image upload ----------
    attachBtn.addEventListener("click", () => {
      imageInput.click();
    });

    imageInput.addEventListener("change", async () => {
      if (!imageInput.files || !imageInput.files[0]) return;
      const file = imageInput.files[0];

      // Show a thumbnail bubble like ChatGPT
      const reader = new FileReader();
      reader.onload = () => {
        const wrapper = document.createElement("div");
        wrapper.classList.add("message", "message-user", "image-message");

        const img = document.createElement("img");
        img.src = reader.result;
        wrapper.appendChild(img);

        chatContainer.appendChild(wrapper);
        chatContainer.scrollTop = chatContainer.scrollHeight;
      };
      reader.readAsDataURL(file);

      // Update location before sending
      await refreshLocation();

      const typingBubble = document.createElement("div");
      typingBubble.classList.add("message", "message-bot", "typing");
      typingBubble.textContent = "Analyzing image‚Ä¶";
      chatContainer.appendChild(typingBubble);
      chatContainer.scrollTop = chatContainer.scrollHeight;

      const formData = new FormData();
      formData.append("image", file);

      try {
        const res = await fetch("/upload_image", {
          method: "POST",
          body: formData,
        });
        const data = await res.json();
        chatContainer.removeChild(typingBubble);
        appendMessage(data.reply || "Image received.", "bot");
      } catch (err) {
        chatContainer.removeChild(typingBubble);
        appendMessage("Error uploading image.", "bot");
        console.error(err);
      } finally {
        imageInput.value = "";
      }
    });

    // ---------- Live video (AR-like) ----------
    async function startVideoStream() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("Camera not supported on this device/browser.");
        return;
      }
      try {
        videoStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio: false,
        });
        liveVideo.srcObject = videoStream;
      } catch (err) {
        console.error("Error starting video:", err);
        alert("Could not start camera.");
      }
    }

    function stopVideoStream() {
      if (videoStream) {
        videoStream.getTracks().forEach((t) => t.stop());
        videoStream = null;
      }
      liveVideo.srcObject = null;
    }

    function showChatScreen() {
      chatScreen.classList.add("active");
      liveScreen.classList.remove("active");
    }

    function showLiveScreen() {
      liveScreen.classList.add("active");
      chatScreen.classList.remove("active");
    }

    goLiveBtn.addEventListener("click", async () => {
      showLiveScreen();
      await startVideoStream();
      // Optional: refresh location on entering live view
      refreshLocation().catch(console.error);
    });

    backToChatBtn.addEventListener("click", () => {
      stopVideoStream();
      showChatScreen();
    });

    window.addEventListener("load", () => {
      input.focus();
    });

const liveScanBtn = document.getElementById("live-scan-btn");
const liveResultCard = document.getElementById("live-result-card");
const liveResultText = document.getElementById("live-result-text");
const liveViewMoreBtn = document.getElementById("live-view-more-btn");
const liveFrame = document.getElementById("live-frame");

let lastLiveResultJson = null;

// Tap the frame to scan
liveFrame.addEventListener("click", () => liveScanBtn.click());

async function captureFrameFromVideo() {
  if (!liveVideo || !liveVideo.videoWidth || !liveVideo.videoHeight) {
    throw new Error("Video not ready");
  }

  const vw = liveVideo.videoWidth;
  const vh = liveVideo.videoHeight;

  const frameWidthRatio = 0.7;
  const frameHeightRatio = 0.4;
  const frameTopRatio = 0.2;

  const sw = vw * frameWidthRatio;
  const sh = vh * frameHeightRatio;
  const sx = (vw - sw) / 2;
  const sy = vh * frameTopRatio;

  const canvas = document.createElement("canvas");
  canvas.width = Math.floor(sw);
  canvas.height = Math.floor(sh);

  const ctx = canvas.getContext("2d");
  ctx.drawImage(liveVideo, sx, sy, sw, sh, 0, 0, sw, sh);

  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob) => (blob ? resolve(blob) : reject(new Error("Failed to create blob"))),
      "image/jpeg",
      0.9
    );
  });
}

liveScanBtn.addEventListener("click", async () => {
  await refreshLocation();

  liveScanBtn.disabled = true;
  liveScanBtn.textContent = "Scanning‚Ä¶";
  liveFrame.classList.add("scanning");


  try {
    const blob = await captureFrameFromVideo();
    const formData = new FormData();
    formData.append("image", blob, "live_frame.jpg");

    const res = await fetch("/live_scan", { method: "POST", body: formData });
    const data = await res.json();

    if (data.error) {
      lastLiveResultJson = null;
      liveResultText.textContent = data.error;
      liveResultCard.classList.remove("hidden");
      return;
    }

    lastLiveResultJson = data;

    const enriched = data.enriched;
    const top = data.top_pick;
    const aiText = data.yelp_ai?.text;

    if (enriched) {
      const ratingLine =
        `‚≠ê ${enriched.rating ?? "‚Äî"} (${enriched.review_count ?? "‚Äî"})` +
        (enriched.price ? ` ‚Ä¢ ${enriched.price}` : "");
      const oneLiner = enriched.ai_summary?.one_liner ? `\n${enriched.ai_summary.one_liner}` : "";
      liveResultText.textContent = `${enriched.name}\n${ratingLine}${oneLiner}`;
    } else if (top) {
      const ratingLine =
        `‚≠ê ${top.rating ?? "‚Äî"} (${top.review_count ?? "‚Äî"})` +
        (top.price ? ` ‚Ä¢ ${top.price}` : "");
      liveResultText.textContent = `${top.name}\n${ratingLine}` + (aiText ? `\n\nü§ñ ${aiText}` : "");
    } else {
      liveResultText.textContent = aiText || "No matching businesses found.";
    }

    liveResultCard.classList.remove("hidden");
  } catch (err) {
    console.error("Live scan error:", err);
    lastLiveResultJson = null;
    liveResultText.textContent = "Error analyzing this view.";
    liveResultCard.classList.remove("hidden");
  } finally {
    liveScanBtn.disabled = false;
    liveScanBtn.textContent = "Scan inside frame";
    liveFrame.classList.remove("scanning");

  }
});
liveViewMoreBtn.addEventListener("click", async () => {
  if (lastLiveResultJson) {
    const enriched = lastLiveResultJson.enriched;
    const top = lastLiveResultJson.top_pick;
    const aiText = lastLiveResultJson.yelp_ai?.text;

    const lines = [];
    lines.push("üìç Live Scan Result");

    if (enriched) {
      lines.push(enriched.name);
      lines.push(`‚≠ê ${enriched.rating ?? "‚Äî"} (${enriched.review_count ?? "‚Äî"})${enriched.price ? " ‚Ä¢ " + enriched.price : ""}`);
      if (enriched.ai_summary?.one_liner) lines.push(`üß† ${enriched.ai_summary.one_liner}`);
    } else if (top) {
      lines.push(top.name);
      lines.push(`‚≠ê ${top.rating ?? "‚Äî"} (${top.review_count ?? "‚Äî"})${top.price ? " ‚Ä¢ " + top.price : ""}`);
    } else {
      lines.push("No top match found.");
    }

    if (aiText) {
      lines.push("");
      lines.push(aiText);
    }

    // 1) Add to UI chat
    appendMessage(lines.join("\n"), "bot");

    // 2) Inject into Yelp context (so followups know what was scanned)
    try {
      await fetch("/inject_context", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ card: lastLiveResultJson }),
      });
    } catch (e) {
      console.error("Failed to inject context:", e);
    }}


  stopVideoStream();
  showChatScreen();
});





  </script>
</body>
</html>
